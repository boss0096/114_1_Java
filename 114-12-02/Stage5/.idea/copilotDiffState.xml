<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Defendable.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Defendable.java" />
              <option name="updatedContent" value="/**&#10; * Defendable 介面：防禦能力&#10; * 實作此介面的角色可以進行防禦動作&#10; */&#10;public interface Defendable {&#10;    /**&#10;     * 取得防禦力&#10;     */&#10;    int getDefenseCapacity();&#10;    &#10;    /**&#10;     * 檢查是否可以防禦&#10;     */&#10;    boolean canDefend();&#10;    &#10;    /**&#10;     * 執行防禦動作&#10;     */&#10;    void defend();&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Healable.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Healable.java" />
              <option name="updatedContent" value="/**&#10; * Healable 介面：治療能力&#10; * 實作此介面的角色可以進行治療動作&#10; */&#10;public interface Healable {&#10;    /**&#10;     * 取得治療力&#10;     */&#10;    int getHealPower();&#10;    &#10;    /**&#10;     * 檢查是否可以治療&#10;     */&#10;    boolean canHeal();&#10;    &#10;    /**&#10;     * 執行治療動作&#10;     */&#10;    void heal(Role target);&#10;    &#10;    /**&#10;     * 預設方法：顯示治療資訊&#10;     */&#10;    default void showHealInfo() {&#10;        System.out.println(&quot;    治療類型：魔法治癒&quot;);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Magician.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Magician.java" />
              <option name="originalContent" value="public class Magician extends RangedRole {&#10;    // 治癒力&#10;    private int healPower;&#10;&#10;    // 建構子：初始化魔法師的名稱、生命值和攻擊力、治癒力、射程、最大能量&#10;    public Magician(String name, int health, int attackPower, int healPower, int range, int maxEnergy) {&#10;        super(name, health, attackPower, range, maxEnergy);&#10;        this.healPower = healPower;&#10;    }&#10;&#10;    // 取得治癒力&#10;    public int getHealPower() {&#10;        return healPower;&#10;    }&#10;&#10;    // 攻擊對手（消耗能量）&#10;    @Override&#10;    public void attack(Role opponent) {&#10;        int cost = 20; // 每次攻擊消耗能量&#10;        if (!consumeEnergy(cost)) {&#10;            System.out.println(&quot;⚠️ &quot; + this.getName() + &quot; 能量不足，無法施放攻擊！&quot;);&#10;            return;&#10;        }&#10;        System.out.println(&quot;✨ &quot; + this.getName() + &quot; 施放魔法攻擊 &quot; + opponent.getName() + &quot;！(消耗 &quot; + cost + &quot; 能量)&quot;);&#10;        opponent.takeDamage(this.getAttackPower()); // 使用 takeDamage 方法&#10;    }&#10;&#10;    // 治療隊友（會消耗能量）&#10;    public void heal(Role ally) {&#10;        int cost = 25; // 治療消耗能量&#10;        if (!consumeEnergy(cost)) {&#10;            System.out.println(&quot;⚠️ &quot; + this.getName() + &quot; 能量不足，無法施放治癒！&quot;);&#10;            return;&#10;        }&#10;        int oldHealth = ally.getHealth();&#10;        ally.setHealth(ally.getHealth() + this.healPower);&#10;        System.out.println(&quot; &quot; + this.getName() + &quot; 治療 &quot; + ally.getName() + &#10;                         &quot; 回復 &quot; + healPower + &quot; 點生命值。(消耗 &quot; + cost + &quot; 能量)&quot; +&#10;                         &quot;(&quot; + oldHealth + &quot; → &quot; + ally.getHealth() + &quot;)&quot;);&#10;    }&#10;&#10;    // 展示特殊技能&#10;    @Override&#10;    public void showSpecialSkill() {&#10;        System.out.println(&quot;╔═════════════════════════════╗&quot;);&#10;        System.out.println(&quot;║ &quot; + this.getName() + &quot; 的特殊技能        ║&quot;);&#10;        System.out.println(&quot;╠═════════════════════════════╣&quot;);&#10;        System.out.println(&quot;║ 技能名稱：元素爆發          ║&quot;);&#10;        System.out.println(&quot;║ 技能描述：召喚強大魔法攻擊  ║&quot;);&#10;        System.out.println(&quot;║ 技能效果：範圍魔法傷害      ║&quot;);&#10;        System.out.println(&quot;║ 額外效果：恢復自身魔力      ║&quot;);&#10;        System.out.println(&quot;╚═════════════════════════════╝&quot;);&#10;    }&#10;&#10;    // ========== 第二階段新增：實作死亡和戰鬥相關抽象方法 ==========&#10;&#10;    /**&#10;     * 魔法師的死亡效果&#10;     */&#10;    @Override&#10;    public void onDeath() {&#10;        System.out.println(&quot; &quot; + this.getName() + &quot; 的生命之火熄滅了...&quot;);&#10;        System.out.println(&quot;✨ &quot; + this.getName() + &quot; 的身體化為無數魔法粒子，消散在空氣中。&quot;);&#10;        System.out.println(&quot; 魔法書掉落在地上，微微發光。&quot;);&#10;        System.out.println(&quot;---&quot;);&#10;    }&#10;&#10;    /**&#10;     * 魔法師的戰前準備&#10;     */&#10;    @Override&#10;    public void prepareBattle() {&#10;        System.out.println(&quot; &quot; + this.getName() + &quot; 翻開魔法書，開始吟唱古老的咒語...&quot;);&#10;        System.out.println(&quot;✨ 魔法能量在周圍凝聚，空氣中閃爍著神秘的光芒。&quot;);&#10;    }&#10;&#10;    /**&#10;     * 魔法師的戰後行為&#10;     */&#10;    @Override&#10;    public void afterBattle() {&#10;        // 戰後恢復少量能量&#10;        recoverEnergy(20);&#10;        System.out.println(&quot; &quot; + this.getName() + &quot; 閉目冥想，恢復消耗的魔力。(+20 能量)&quot;);&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return super.toString() + &quot;, 治癒力: &quot; + healPower +&#10;               &quot;, 射程: &quot; + getRange() + &quot;, 能量: &quot; + getEnergy() + &quot;/&quot; + getMaxEnergy();&#10;    }&#10;&#10;    @Override&#10;    public String getRangedAttackType() {&#10;        return &quot;魔法攻擊&quot;;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="public class Magician extends RangedRole implements Healable {&#10;    // 治癒力&#10;    private int healPower;&#10;&#10;    // 建構子：初始化魔法師的名稱、生命值和攻擊力、治癒力、射程、最大能量&#10;    public Magician(String name, int health, int attackPower, int healPower, int range, int maxEnergy) {&#10;        super(name, health, attackPower, range, maxEnergy);&#10;        this.healPower = healPower;&#10;    }&#10;&#10;    // 取得治癒力&#10;    @Override&#10;    public int getHealPower() {&#10;        return healPower;&#10;    }&#10;&#10;    // ⭐ 實現 Healable 介面方法&#10;    @Override&#10;    public boolean canHeal() {&#10;        return getEnergy() &gt;= 25;&#10;    }&#10;&#10;    // 攻擊對手（消耗能量）&#10;    @Override&#10;    public void attack(Role opponent) {&#10;        int cost = 20; // 每次攻擊消耗能量&#10;        if (!consumeEnergy(cost)) {&#10;            System.out.println(&quot;⚠️ &quot; + this.getName() + &quot; 能量不足，無法施放攻擊！&quot;);&#10;            return;&#10;        }&#10;        System.out.println(&quot;✨ &quot; + this.getName() + &quot; 施放魔法攻擊 &quot; + opponent.getName() + &quot;！(消耗 &quot; + cost + &quot; 能量)&quot;);&#10;        opponent.takeDamage(this.getAttackPower()); // 使用 takeDamage 方法&#10;    }&#10;&#10;    // 治療隊友（會消耗能量）&#10;    @Override&#10;    public void heal(Role ally) {&#10;        int cost = 25; // 治療消耗能量&#10;        if (!consumeEnergy(cost)) {&#10;            System.out.println(&quot;⚠️ &quot; + this.getName() + &quot; 能量不足，無法施放治癒！&quot;);&#10;            return;&#10;        }&#10;        int oldHealth = ally.getHealth();&#10;        ally.setHealth(ally.getHealth() + this.healPower);&#10;        System.out.println(&quot; &quot; + this.getName() + &quot; 治療 &quot; + ally.getName() + &#10;                         &quot; 回復 &quot; + healPower + &quot; 點生命值。(消耗 &quot; + cost + &quot; 能量)&quot; +&#10;                         &quot;(&quot; + oldHealth + &quot; → &quot; + ally.getHealth() + &quot;)&quot;);&#10;    }&#10;&#10;    // 展示特殊技能&#10;    @Override&#10;    public void showSpecialSkill() {&#10;        System.out.println(&quot;╔═════════════════════════════╗&quot;);&#10;        System.out.println(&quot;║ &quot; + this.getName() + &quot; 的特殊技能        ║&quot;);&#10;        System.out.println(&quot;╠═════════════════════════════╣&quot;);&#10;        System.out.println(&quot;║ 技能名稱：元素爆發          ║&quot;);&#10;        System.out.println(&quot;║ 技能描述：召喚強大魔法攻擊  ║&quot;);&#10;        System.out.println(&quot;║ 技能效果：範圍魔法傷害      ║&quot;);&#10;        System.out.println(&quot;║ 額外效果：恢復自身魔力      ║&quot;);&#10;        System.out.println(&quot;╚═════════════════════════════╝&quot;);&#10;    }&#10;&#10;    // ========== 第二階段新增：實作死亡和戰鬥相關抽象方法 ==========&#10;&#10;    /**&#10;     * 魔法師的死亡效果&#10;     */&#10;    @Override&#10;    public void onDeath() {&#10;        System.out.println(&quot; &quot; + this.getName() + &quot; 的生命之火熄滅了...&quot;);&#10;        System.out.println(&quot;✨ &quot; + this.getName() + &quot; 的身體化為無數魔法粒子，消散在空氣中。&quot;);&#10;        System.out.println(&quot; 魔法書掉落在地上，微微發光。&quot;);&#10;        System.out.println(&quot;---&quot;);&#10;    }&#10;&#10;    /**&#10;     * 魔法師的戰前準備&#10;     */&#10;    @Override&#10;    public void prepareBattle() {&#10;        System.out.println(&quot; &quot; + this.getName() + &quot; 翻開魔法書，開始吟唱古老的咒語...&quot;);&#10;        System.out.println(&quot;✨ 魔法能量在周圍凝聚，空氣中閃爍著神秘的光芒。&quot;);&#10;    }&#10;&#10;    /**&#10;     * 魔法師的戰後行為&#10;     */&#10;    @Override&#10;    public void afterBattle() {&#10;        // 戰後恢復少量能量&#10;        recoverEnergy(20);&#10;        System.out.println(&quot; &quot; + this.getName() + &quot; 閉目冥想，恢復消耗的魔力。(+20 能量)&quot;);&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return super.toString() + &quot;, 治癒力: &quot; + healPower +&#10;               &quot;, 射程: &quot; + getRange() + &quot;, 能量: &quot; + getEnergy() + &quot;/&quot; + getMaxEnergy();&#10;    }&#10;&#10;    @Override&#10;    public String getRangedAttackType() {&#10;        return &quot;魔法攻擊&quot;;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Role.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Role.java" />
              <option name="originalContent" value="public abstract class Role {&#10;    // 角色名稱&#10;    private String name;&#10;    // 生命值&#10;    private int health;&#10;    // 攻擊力&#10;    private int attackPower;&#10;&#10;    // 建構子：初始化角色的名稱、生命值和攻擊力&#10;    public Role(String name, int health, int attackPower) {&#10;        this.name = name;&#10;        this.health = health;&#10;        this.attackPower = attackPower;&#10;    }&#10;&#10;    // 取得角色名稱&#10;    public String getName() {&#10;        return name;&#10;    }&#10;&#10;    // 取得生命值&#10;    public int getHealth() {&#10;        return health;&#10;    }&#10;&#10;    // 取得攻擊力&#10;    public int getAttackPower() {&#10;        return attackPower;&#10;    }&#10;    &#10;    // 設定生命值&#10;    public void setHealth(int health) {&#10;        this.health = health;&#10;    }&#10;&#10;    // 檢查角色是否存活&#10;    public boolean isAlive() {&#10;        return health &gt; 0;&#10;    }&#10;&#10;    // 抽象方法：攻擊對手&#10;    public abstract void attack(Role opponent);&#10;&#10;    // 抽象方法：展示角色的特殊技能&#10;    public abstract void showSpecialSkill();&#10;&#10;    // ========== 第二階段新增：具體方法 + 抽象方法的結合 ==========&#10;    &#10;    /**&#10;     * 受到傷害（具體方法）&#10;     * 為什麼是具體方法？&#10;     * 1. 所有角色受傷的「基本流程」都相同：扣血 → 顯示訊息 → 檢查是否死亡&#10;     * 2. 這是「共通邏輯」，可以在父類別統一實作&#10;     * 3. 避免每個子類別都要寫一次相同的程式碼&#10;     * &#10;     * @param damage 受到的傷害值&#10;     */&#10;    public void takeDamage(int damage) {&#10;        this.health -= damage;&#10;        System.out.println(&quot; &quot; + name + &quot; 受到 &quot; + damage + &quot; 點傷害！目前生命值：&quot; + health);&#10;        &#10;        // 如果角色死亡，呼叫抽象方法 onDeath()&#10;        if (!isAlive()) {&#10;            onDeath(); // 每個角色的死亡效果不同，交由子類別實作&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 死亡時的處理（抽象方法）&#10;     * 為什麼是抽象方法？&#10;     * 1. 每個角色死亡時的「表現方式」都不同&#10;     * 2. 劍士：劍掉落在地&#10;     * 3. 魔法師：化為魔法粒子消失&#10;     * 4. 這是「個別差異」，必須由子類別各自實作&#10;     */&#10;    public abstract void onDeath();&#10;&#10;    /**&#10;     * 戰鬥前的準備動作（抽象方法）&#10;     * 為什麼是抽象方法？&#10;     * 1. 每個角色的準備動作都不同&#10;     * 2. 劍士：擦拭劍刃&#10;     * 3. 魔法師：吟唱咒語&#10;     */&#10;    public abstract void prepareBattle();&#10;&#10;    /**&#10;     * 戰鬥後的行為（抽象方法）&#10;     * 為什麼是抽象方法？&#10;     * 1. 每個角色戰後行為都不同&#10;     * 2. 劍士：收劍入鞘&#10;     * 3. 魔法師：恢復魔力&#10;     */&#10;    public abstract void afterBattle();&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;角色名稱: &quot; + name + &quot;, 生命值: &quot; + health;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="public abstract class Role {&#10;    // 角色名稱&#10;    private String name;&#10;    // 生命值&#10;    private int health;&#10;    // 最大生命值&#10;    private int maxHealth;&#10;    // 攻擊力&#10;    private int attackPower;&#10;&#10;    // 建構子：初始化角色的名稱、生命值和攻擊力&#10;    public Role(String name, int health, int attackPower) {&#10;        this.name = name;&#10;        this.health = health;&#10;        this.maxHealth = health;&#10;        this.attackPower = attackPower;&#10;    }&#10;&#10;    // 取得角色名稱&#10;    public String getName() {&#10;        return name;&#10;    }&#10;&#10;    // 取得生命值&#10;    public int getHealth() {&#10;        return health;&#10;    }&#10;&#10;    // 取得最大生命值&#10;    public int getMaxHealth() {&#10;        return maxHealth;&#10;    }&#10;&#10;    // 取得攻擊力&#10;    public int getAttackPower() {&#10;        return attackPower;&#10;    }&#10;    &#10;    // 設定生命值&#10;    public void setHealth(int health) {&#10;        this.health = health;&#10;    }&#10;&#10;    // 檢查角色是否存活&#10;    public boolean isAlive() {&#10;        return health &gt; 0;&#10;    }&#10;&#10;    // 抽象方法：攻擊對手&#10;    public abstract void attack(Role opponent);&#10;&#10;    // 抽象方法：展示角色的特殊技能&#10;    public abstract void showSpecialSkill();&#10;&#10;    // ========== 第二階段新增：具體方法 + 抽象方法的結合 ==========&#10;    &#10;    /**&#10;     * 受到傷害（具體方法）&#10;     * 為什麼是具體方法？&#10;     * 1. 所有角色受傷的「基本流程」都相同：扣血 → 顯示訊息 → 檢查是否死亡&#10;     * 2. 這是「共通邏輯」，可以在父類別統一實作&#10;     * 3. 避免每個子類別都要寫一次相同的程式碼&#10;     * &#10;     * @param damage 受到的傷害值&#10;     */&#10;    public void takeDamage(int damage) {&#10;        this.health -= damage;&#10;        System.out.println(&quot; &quot; + name + &quot; 受到 &quot; + damage + &quot; 點傷害！目前生命值：&quot; + health);&#10;        &#10;        // 如果角色死亡，呼叫抽象方法 onDeath()&#10;        if (!isAlive()) {&#10;            onDeath(); // 每個角色的死亡效果不同，交由子類別實作&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 死亡時的處理（抽象方法）&#10;     * 為什麼是抽象方法？&#10;     * 1. 每個角色死亡時的「表現方式」都不同&#10;     * 2. 劍士：劍掉落在地&#10;     * 3. 魔法師：化為魔法粒子消失&#10;     * 4. 這是「個別差異」，必須由子類別各自實作&#10;     */&#10;    public abstract void onDeath();&#10;&#10;    /**&#10;     * 戰鬥前的準備動作（抽象方法）&#10;     * 為什麼是抽象方法？&#10;     * 1. 每個角色的準備動作都不同&#10;     * 2. 劍士：擦拭劍刃&#10;     * 3. 魔法師：吟唱咒語&#10;     */&#10;    public abstract void prepareBattle();&#10;&#10;    /**&#10;     * 戰鬥後的行為（抽象方法）&#10;     * 為什麼是抽象方法？&#10;     * 1. 每個角色戰後行為都不同&#10;     * 2. 劍士：收劍入鞘&#10;     * 3. 魔法師：恢復魔力&#10;     */&#10;    public abstract void afterBattle();&#10;&#10;    @Override&#10;    public String toString() {&#10;        return &quot;角色名稱: &quot; + name + &quot;, 生命值: &quot; + health;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/ShieldSwordsMan.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/ShieldSwordsMan.java" />
              <option name="originalContent" value="public class ShieldSwordsMan extends SwordsMan {&#10;    private int defenseCapacity;&#10;&#10;    // 建構子：初始化持盾劍士的名稱、生命值、攻擊力、護甲與防禦數值&#10;    public ShieldSwordsMan(String name, int health, int attackPower, int armor, int defenseCapacity) {&#10;        super(name, health, attackPower, armor);&#10;        this.defenseCapacity = defenseCapacity;&#10;    }&#10;&#10;    // 攻擊對手（持盾劍士攻擊力較低）&#10;    @Override&#10;    public void attack(Role opponent) {&#10;        int reducedDamage = this.getAttackPower() - 5; // 持盾劍士攻擊力減少5點&#10;        System.out.println(&quot;️⚔️  &quot; + this.getName() + &quot; 單手揮劍攻擊 &quot; + opponent.getName() + &quot;！&quot;);&#10;        opponent.takeDamage(reducedDamage); // 使用 takeDamage 方法&#10;    }&#10;&#10;    public int getDefenseCapacity() {&#10;        return defenseCapacity;&#10;    }&#10;&#10;    // 防禦能力&#10;    public void defence() {&#10;        int oldHealth = this.getHealth();&#10;        this.setHealth(this.getHealth() + defenseCapacity);&#10;        System.out.println(&quot;️  &quot; + this.getName() + &quot; 舉起盾牌防禦！恢復 &quot; + defenseCapacity + &#10;                         &quot; 點生命值。(&quot; + oldHealth + &quot; → &quot; + this.getHealth() + &quot;)&quot;);&#10;    }&#10;&#10;    // 展示特殊技能（覆寫父類別）&#10;    @Override&#10;    public void showSpecialSkill() {&#10;        System.out.println(&quot;╔═════════════════════════════╗&quot;);&#10;        System.out.println(&quot;║ &quot; + this.getName() + &quot; 的特殊技能      ║&quot;);&#10;        System.out.println(&quot;╠═════════════════════════════╣&quot;);&#10;        System.out.println(&quot;║ 技能名稱：盾牌猛擊          ║&quot;);&#10;        System.out.println(&quot;║ 技能描述：使用盾牌撞擊敵人  ║&quot;);&#10;        System.out.println(&quot;║ 技能效果：造成傷害並暈眩    ║&quot;);&#10;        System.out.println(&quot;║ 防禦加成：+&quot; + defenseCapacity + &quot; 防禦力           ║&quot;);&#10;        System.out.println(&quot;╚═════════════════════════════╝&quot;);&#10;    }&#10;&#10;    // ========== 第二階段新增：覆寫死亡和戰鬥相關方法 ==========&#10;&#10;    /**&#10;     * 持盾劍士的死亡效果&#10;     * 持盾劍士死亡時，盾牌和劍都會掉落&#10;     * 注意：這裡展示了「繼承後再覆寫」的能力&#10;     */&#10;    @Override&#10;    public void onDeath() {&#10;        System.out.println(&quot; &quot; + this.getName() + &quot; 力竭倒下...&quot;);&#10;        System.out.println(&quot;️  厚重的盾牌砸在地上，揚起一陣塵土。&quot;);&#10;        System.out.println(&quot;⚔️  &quot; + this.getName() + &quot; 的劍也隨之掉落。&quot;);&#10;        System.out.println(&quot;---&quot;);&#10;    }&#10;&#10;    /**&#10;     * 持盾劍士的戰前準備&#10;     * 檢查盾牌和劍的狀態&#10;     */&#10;    @Override&#10;    public void prepareBattle() {&#10;        System.out.println(&quot;️  &quot; + this.getName() + &quot; 檢查盾牌的牢固程度...&quot;);&#10;        System.out.println(&quot;⚔️  同時確認劍刃的鋒利度，準備應戰。&quot;);&#10;    }&#10;&#10;    /**&#10;     * 持盾劍士的戰後行為&#10;     * 修復盾牌上的損傷&#10;     */&#10;    @Override&#10;    public void afterBattle() {&#10;        System.out.println(&quot;️  &quot; + this.getName() + &quot; 檢視盾牌上的新傷痕，並進行簡單修補。&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="public class ShieldSwordsMan extends SwordsMan implements Defendable {&#10;    private int defenseCapacity;&#10;&#10;    // 建構子：初始化持盾劍士的名稱、生命值、攻擊力、護甲與防禦數值&#10;    public ShieldSwordsMan(String name, int health, int attackPower, int armor, int defenseCapacity) {&#10;        super(name, health, attackPower, armor);&#10;        this.defenseCapacity = defenseCapacity;&#10;    }&#10;&#10;    // 攻擊對手（持盾劍士攻擊力較低）&#10;    @Override&#10;    public void attack(Role opponent) {&#10;        int reducedDamage = this.getAttackPower() - 5; // 持盾劍士攻擊力減少5點&#10;        System.out.println(&quot;️⚔️  &quot; + this.getName() + &quot; 單手揮劍攻擊 &quot; + opponent.getName() + &quot;！&quot;);&#10;        opponent.takeDamage(reducedDamage); // 使用 takeDamage 方法&#10;    }&#10;&#10;    public int getDefenseCapacity() {&#10;        return defenseCapacity;&#10;    }&#10;&#10;    // ⭐ 實現 Defendable 介面方法&#10;    @Override&#10;    public boolean canDefend() {&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public void defend() {&#10;        int oldHealth = this.getHealth();&#10;        this.setHealth(this.getHealth() + defenseCapacity);&#10;        System.out.println(&quot;️  &quot; + this.getName() + &quot; 舉起盾牌防禦！恢復 &quot; + defenseCapacity + &#10;                         &quot; 點生命值。(&quot; + oldHealth + &quot; → &quot; + this.getHealth() + &quot;)&quot;);&#10;    }&#10;&#10;    // 展示特殊技能（覆寫父類別）&#10;    @Override&#10;    public void showSpecialSkill() {&#10;        System.out.println(&quot;╔═════════════════════════════╗&quot;);&#10;        System.out.println(&quot;║ &quot; + this.getName() + &quot; 的特殊技能      ║&quot;);&#10;        System.out.println(&quot;╠═════════════════════════════╣&quot;);&#10;        System.out.println(&quot;║ 技能名稱：盾牌猛擊          ║&quot;);&#10;        System.out.println(&quot;║ 技能描述：使用盾牌撞擊敵人  ║&quot;);&#10;        System.out.println(&quot;║ 技能效果：造成傷害並暈眩    ║&quot;);&#10;        System.out.println(&quot;║ 防禦加成：+&quot; + defenseCapacity + &quot; 防禦力           ║&quot;);&#10;        System.out.println(&quot;╚═════════════════════════════╝&quot;);&#10;    }&#10;&#10;    // ========== 第二階段新增：覆寫死亡和戰鬥相關方法 ==========&#10;&#10;    /**&#10;     * 持盾劍士的死亡效果&#10;     * 持盾劍士死亡時，盾牌和劍都會掉落&#10;     * 注意：這裡展示了「繼承後再覆寫」的能力&#10;     */&#10;    @Override&#10;    public void onDeath() {&#10;        System.out.println(&quot; &quot; + this.getName() + &quot; 力竭倒下...&quot;);&#10;        System.out.println(&quot;️  厚重的盾牌砸在地上，揚起一陣塵土。&quot;);&#10;        System.out.println(&quot;⚔️  &quot; + this.getName() + &quot; 的劍也隨之掉落。&quot;);&#10;        System.out.println(&quot;---&quot;);&#10;    }&#10;&#10;    /**&#10;     * 持盾劍士的戰前準備&#10;     * 檢查盾牌和劍的狀態&#10;     */&#10;    @Override&#10;    public void prepareBattle() {&#10;        System.out.println(&quot;️  &quot; + this.getName() + &quot; 檢查盾牌的牢固程度...&quot;);&#10;        System.out.println(&quot;⚔️  同時確認劍刃的鋒利度，準備應戰。&quot;);&#10;    }&#10;&#10;    /**&#10;     * 持盾劍士的戰後行為&#10;     * 修復盾牌上的損傷&#10;     */&#10;    @Override&#10;    public void afterBattle() {&#10;        System.out.println(&quot;️  &quot; + this.getName() + &quot; 檢視盾牌上的新傷痕，並進行簡單修補。&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>